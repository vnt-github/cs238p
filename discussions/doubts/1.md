Q9 ESP after a CALL
10 Points
According to the call convention discussed in class; Where is the register ESP pointing to, right after executing a CALL instruction?

Choice 1 of 4:The value of the return address.
Choice 2 of 4:The address of the next instruction.
Choice 3 of 4:The value of the previous EBP.
Choice 4 of 4:The value of the previous EIP.
ANSWER
The value of the return address.

- i thought from the perspective of tHe caller, so the Next address will be tHe value of ESP.
    - how choice 1 and choice 2 differ.

- give example of thunk function that is trick to get next instruction address.

---
# logistics

- for final will more emphasis be for topics after paging? because syllabus is too vast, i've been watching just OS lectures and i still difficult for me to keep track of all the concepts and theory.
- for hw5, i was struggling with the problem which someone else just described on piazza, i explained this to TA elahe she also didn't know how to help.
    - i also tried merging fork and exec, like i understood exec and fork so that i could comment, edit and combine but it's still working like 50% of time. sometimes i get result sometime i get trap error and i am stuck.

- on 2019 there were questions on threads?
    - on t
---
# final 2018 fall
- 1 c) Is there a possiblity for swtch to be reached without reaching the alltraps from any other path flow? like from scheduler function?
- 1 d) No answer.
    - inside the sched
        - i would use a FIFO(first in first out) double ended queue(deque) using linked list to maintain the list of RUNNABLE only processes.
        - wherever that process state changes to RUNNABLE i modify those to add to this back of FIFO deque.
            - like fork, wakeup1, yield, kill etc.
        - pick process from head and context switch to head instead to scheduler.

- 5 c) solved: pending.
    - is hw_encrypt async? YES
```c
struct {
    int encrypting;
    struct spinlock lock;
} cdev;

int encrypt_block(cdev cd, buffer b, key k) {
    while (1) {
        acquire(&cd.lock);
        .
        if (!cd.encrypting) {
            cd.encrypting = 1;
            .
            hw_encrypt(b, k);
            .
            sleep(cd, &cd.lock);
            .
            release(&cd.lock);
            .
            // ON WAKE UP EITHER THIS WAKES
            // SO NEED A WAY TO SEPARATE DIFFERENT WAKERS.
            return 0;
        } else {
            // ON WAKE UP OR THIS WAKES 
            // THIS IS MORE LIKELY AS MORE PROCESSES CAN BE HERE.
            sleep(cd, &cd.lock);
        }
    }
}

/* Interrupt handler for the encryption device */
void encrypt_int(void) {
    cd = cdev;
    acquire(&cd->lock);
    // Wake process waiting for this buf.
    cd->encrypting = 0;
    wakeup(cd);
    release(&cd->lock);
}

```
# final 2018 winter
- 3 c). are we expected to know about threads. how to start thinking about it.

- 5. can't see how we'll get bbb bbb aaa, because child goes to sleep(1) after writing.
---

- kernel is mapped twice in virtual memory and linear memory.
- **why did we map kernel twice?**

- **what is the con with this arrangement for allocator?**
    - one is the size is fixed 4096 bytes
        - so a lot of wastage

- **why kinit2(P2V(4*1024*1024)) // must come after startothers?**
    - is it because memory mapped till 4MB is enough for 1 processor. 
    - **why can't you move kinit2 up after seginit();**
        - is it after installing a full page table that maps them on all cores. then if we don't startothers then only the BSP processor will have all the pages.

- **EXAM QUESTIONS: why do we have GDT for each CPU in place of having a one GDT for entire system.**
    - because the GDT also contains the TSS which points to per process kernel stack and hence can't be shared. 


- DOUBT: 
```c
2836 // Reacquire original lock.
2837 if(lk != &ptable.lock){
2838    release(&ptable.lock);
2839    acquire(lk);
2840 }

- **EXAM why line 2838 and 2839 is not flipped**?
    - i read the book and got more confused.